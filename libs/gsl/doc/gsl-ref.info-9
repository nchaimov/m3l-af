This is gsl-ref.info, produced by makeinfo version 4.2 from
gsl-ref.texi.

INFO-DIR-SECTION Scientific software
START-INFO-DIR-ENTRY
* gsl-ref: (gsl-ref).                   GNU Scientific Library - Reference
END-INFO-DIR-ENTRY


File: gsl-ref.info,  Node: Mixed-radix FFT routines for real data,  Next: FFT References and Further Reading,  Prev: Radix-2 FFT routines for real data,  Up: Fast Fourier Transforms

Mixed-radix FFT routines for real data
======================================

   This section describes mixed-radix FFT algorithms for real data.  The
mixed-radix functions work for FFTs of any length.  They are a
reimplementation of the real-FFT routines in the Fortran FFTPACK library
by Paul Swarztrauber.  The theory behind the algorithm is explained in
the article `Fast Mixed-Radix Real Fourier Transforms' by Clive
Temperton.  The routines here use the same indexing scheme and basic
algorithms as FFTPACK.

   The functions use the FFTPACK storage convention for half-complex
sequences.  In this convention the half-complex transform of a real
sequence is stored with frequencies in increasing order, starting at
zero, with the real and imaginary parts of each frequency in neighboring
locations.  When a value is known to be real the imaginary part is not
stored.  The imaginary part of the zero-frequency component is never
stored.  It is known to be zero (since the zero frequency component is
simply the sum of the input data (all real)).  For a sequence of even
length the imaginary part of the frequency n/2 is not stored either,
since the symmetry z_k = z_{N-k}^* implies that this is purely real too.

   The storage scheme is best shown by some examples.  The table below
shows the output for an odd-length sequence, n=5.  The two columns give
the correspondence between the 5 values in the half-complex sequence
returned by `gsl_fft_real_transform', HALFCOMPLEX[] and the values
COMPLEX[] that would be returned if the same real input sequence were
passed to `gsl_fft_complex_backward' as a complex sequence (with
imaginary parts set to `0'),

     complex[0].real  =  halfcomplex[0]
     complex[0].imag  =  0
     complex[1].real  =  halfcomplex[1]
     complex[1].imag  =  halfcomplex[2]
     complex[2].real  =  halfcomplex[3]
     complex[2].imag  =  halfcomplex[4]
     complex[3].real  =  halfcomplex[3]
     complex[3].imag  = -halfcomplex[4]
     complex[4].real  =  halfcomplex[1]
     complex[4].imag  = -halfcomplex[2]

The upper elements of the COMPLEX array, `complex[3]' and `complex[4]'
are filled in using the symmetry condition.  The imaginary part of the
zero-frequency term `complex[0].imag' is known to be zero by the
symmetry.

   The next table shows the output for an even-length sequence, n=5 In
the even case both the there are two values which are purely real,

     complex[0].real  =  halfcomplex[0]
     complex[0].imag  =  0
     complex[1].real  =  halfcomplex[1]
     complex[1].imag  =  halfcomplex[2]
     complex[2].real  =  halfcomplex[3]
     complex[2].imag  =  halfcomplex[4]
     complex[3].real  =  halfcomplex[5]
     complex[3].imag  =  0
     complex[4].real  =  halfcomplex[3]
     complex[4].imag  = -halfcomplex[4]
     complex[5].real  =  halfcomplex[1]
     complex[5].imag  = -halfcomplex[2]

The upper elements of the COMPLEX array, `complex[4]' and `complex[5]'
are filled in using the symmetry condition.  Both `complex[0].imag' and
`complex[3].imag' are known to be zero.

   All these functions are declared in the header files
`gsl_fft_real.h' and `gsl_fft_halfcomplex.h'.

 - Function: gsl_fft_real_wavetable * gsl_fft_real_wavetable_alloc
          (size_t N)
 - Function: gsl_fft_halfcomplex_wavetable *
gsl_fft_halfcomplex_wavetable_alloc (size_t N)
     These functions prepare trigonometric lookup tables for an FFT of
     size n real elements.  The functions return a pointer to the newly
     allocated struct if no errors were detected, and a null pointer in
     the case of error.  The length N is factorized into a product of
     subtransforms, and the factors and their trigonometric
     coefficients are stored in the wavetable. The trigonometric
     coefficients are computed using direct calls to `sin' and `cos',
     for accuracy.  Recursion relations could be used to compute the
     lookup table faster, but if an application performs many FFTs of
     the same length then computing the wavetable is a one-off overhead
     which does not affect the final throughput.

     The wavetable structure can be used repeatedly for any transform
     of the same length.  The table is not modified by calls to any of
     the other FFT functions.  The appropriate type of wavetable must
     be used for forward real or inverse half-complex transforms.

 - Function: void gsl_fft_real_wavetable_free (gsl_fft_real_wavetable *
          WAVETABLE)
 - Function: void gsl_fft_halfcomplex_wavetable_free
          (gsl_fft_halfcomplex_wavetable * WAVETABLE)
     These functions free the memory associated with the wavetable
     WAVETABLE. The wavetable can be freed if no further FFTs of the
     same length will be needed.

The mixed radix algorithms require an additional working space to hold
the intermediate steps of the transform,

 - Function: gsl_fft_real_workspace * gsl_fft_real_workspace_alloc
          (size_t N)
     This function allocates a workspace for a real transform of length
     N.  The same workspace is used for both forward real and inverse
     halfcomplex transforms.

 - Function: void gsl_fft_real_workspace_free (gsl_fft_real_workspace *
          WORKSPACE)
     This function frees the memory associated with the workspace
     WORKSPACE. The workspace can be freed if no further FFTs of the
     same length will be needed.

The following functions compute the transforms of real and half-complex
data,

 - Function: int gsl_fft_real_transform (double DATA[], size_t STRIDE,
          size_t N, const gsl_fft_real_wavetable * WAVETABLE,
          gsl_fft_real_workspace * WORK)
 - Function: int gsl_fft_halfcomplex_transform (double DATA[], size_t
          STRIDE, size_t N, const gsl_fft_halfcomplex_wavetable *
          WAVETABLE, gsl_fft_real_workspace * WORK)
     These functions compute the FFT of DATA, a real or half-complex
     array of length N, using a mixed radix decimation-in-frequency
     algorithm.  For `gsl_fft_real_transform' DATA is an array of
     time-ordered real data.  For `gsl_fft_halfcomplex_transform' DATA
     contains fourier coefficients in the half-complex ordering
     described above.  There is no restriction on the length N.
     Efficient modules are provided for subtransforms of length 2, 3, 4
     and 5.  Any remaining factors are computed with a slow, O(n^2),
     general-n module.  The caller must supply a WAVETABLE containing
     trigonometric lookup tables and a workspace WORK.

 - Function: int gsl_fft_real_unpack (const double REAL_COEFFICIENT[],
          gsl_complex_packed_array COMPLEX_COEFFICIENT[], size_t
          STRIDE, size_t N)
     This function converts a single real array, REAL_COEFFICIENT into
     an equivalent complex array, COMPLEX_COEFFICIENT, (with imaginary
     part set to zero), suitable for `gsl_fft_complex' routines.  The
     algorithm for the conversion is simply,

          for (i = 0; i < n; i++)
            {
              complex_coefficient[i].real
                = real_coefficient[i];
              complex_coefficient[i].imag
                = 0.0;
            }

 - Function: int gsl_fft_halfcomplex_unpack (const double
          HALFCOMPLEX_COEFFICIENT[], gsl_complex_packed_array
          COMPLEX_COEFFICIENT[], size_t STRIDE, size_t N)
     This function converts HALFCOMPLEX_COEFFICIENT, an array of
     half-complex coefficients as returned by `gsl_fft_real_transform',
     into an ordinary complex array, COMPLEX_COEFFICIENT.  It fills in
     the complex array using the symmetry z_k = z_{N-k}^* to
     reconstruct the redundant elements.  The algorithm for the
     conversion is,

          complex_coefficient[0].real
            = halfcomplex_coefficient[0];
          complex_coefficient[0].imag
            = 0.0;
          
          for (i = 1; i < n - i; i++)
            {
              double hc_real
                = halfcomplex_coefficient[2 * i - 1];
              double hc_imag
                = halfcomplex_coefficient[2 * i];
              complex_coefficient[i].real = hc_real;
              complex_coefficient[i].imag = hc_imag;
              complex_coefficient[n - i].real = hc_real;
              complex_coefficient[n - i].imag = -hc_imag;
            }
          
          if (i == n - i)
            {
              complex_coefficient[i].real
                = halfcomplex_coefficient[n - 1];
              complex_coefficient[i].imag
                = 0.0;
            }

   Here is an example program using `gsl_fft_real_transform' and
`gsl_fft_halfcomplex_inverse'.  It generates a real signal in the shape
of a square pulse.  The pulse is fourier transformed to frequency
space, and all but the lowest ten frequency components are removed from
the array of fourier coefficients returned by `gsl_fft_real_transform'.

   The remaining fourier coefficients are transformed back to the
time-domain, to give a filtered version of the square pulse.  Since
fourier coefficients are stored using the half-complex symmetry both
positive and negative frequencies are removed and the final filtered
signal is also real.

     #include <stdio.h>
     #include <math.h>
     #include <gsl/gsl_errno.h>
     #include <gsl/gsl_fft_real.h>
     #include <gsl/gsl_fft_halfcomplex.h>
     
     int
     main (void)
     {
       int i, n = 100;
       double data[n];
     
       gsl_fft_real_wavetable * real;
       gsl_fft_halfcomplex_wavetable * hc;
       gsl_fft_real_workspace * work;
     
       for (i = 0; i < n; i++)
         {
           data[i] = 0.0;
         }
     
       for (i = n / 3; i < 2 * n / 3; i++)
         {
           data[i] = 1.0;
         }
     
       for (i = 0; i < n; i++)
         {
           printf ("%d: %e\n", i, data[i]);
         }
       printf ("\n");
     
       work = gsl_fft_real_workspace_alloc (n);
       real = gsl_fft_real_wavetable_alloc (n);
     
       gsl_fft_real_transform (data, 1, n,
                               real, work);
     
       gsl_fft_real_wavetable_free (real);
     
       for (i = 11; i < n; i++)
         {
           data[i] = 0;
         }
     
       hc = gsl_fft_halfcomplex_wavetable_alloc (n);
     
       gsl_fft_halfcomplex_inverse (data, 1, n,
                                    hc, work);
       gsl_fft_halfcomplex_wavetable_free (hc);
     
       for (i = 0; i < n; i++)
         {
           printf ("%d: %e\n", i, data[i]);
         }
     
       gsl_fft_real_workspace_free (work);
       return 0;
     }


File: gsl-ref.info,  Node: FFT References and Further Reading,  Prev: Mixed-radix FFT routines for real data,  Up: Fast Fourier Transforms

References and Further Reading
==============================

A good starting point for learning more about the FFT is the review
article `Fast Fourier Transforms: A Tutorial Review and A State of the
Art' by Duhamel and Vetterli,

     P. Duhamel and M. Vetterli.  Fast fourier transforms: A tutorial
     review and a state of the art.  `Signal Processing', 19:259-299,
     1990.

To find out about the algorithms used in the GSL routines you may want
to consult the latex document `GSL FFT Algorithms' (it is included in
GSL, as `doc/fftalgorithms.tex').  This has general information on FFTs
and explicit derivations of the implementation for each routine.  There
are also references to the relevant literature.  For convenience some
of the more important references are reproduced below.

There are several introductory books on the FFT with example programs,
such as `The Fast Fourier Transform' by Brigham and `DFT/FFT and
Convolution Algorithms' by Burrus and Parks,

     E. Oran Brigham.  `The Fast Fourier Transform'.  Prentice Hall,
     1974.

     C. S. Burrus and T. W. Parks.  `DFT/FFT and Convolution
     Algorithms'.  Wiley, 1984.

Both these introductory books cover the radix-2 FFT in some detail.
The mixed-radix algorithm at the heart of the FFTPACK routines is
reviewed in Clive Temperton's paper,

     Clive Temperton.  Self-sorting mixed-radix fast fourier transforms.
     `Journal of Computational Physics', 52(1):1-23, 1983.

The derivation of FFTs for real-valued data is explained in the
following two articles,

     Henrik V. Sorenson, Douglas L. Jones, Michael T. Heideman, and C.
     Sidney Burrus.  Real-valued fast fourier transform algorithms.
     `IEEE Transactions on Acoustics, Speech, and Signal Processing',
     ASSP-35(6):849-863, 1987.

     Clive Temperton.  Fast mixed-radix real fourier transforms.
     `Journal of Computational Physics', 52:340-350, 1983.

In 1979 the IEEE published a compendium of carefully-reviewed Fortran
FFT programs in `Programs for Digital Signal Processing'.  It is a
useful reference for implementations of many different FFT algorithms,

     Digital Signal Processing Committee and IEEE Acoustics, Speech,
     and Signal Processing Committee, editors.  `Programs for Digital
     Signal Processing'.  IEEE Press, 1979.

For serious FFT work we recommend the use of the dedicated FFTW library
by Frigo and Johnson.  The FFTW library is self-optimizing -- it
automatically tunes itself for each hardware platform in order to
achieve maximum performance.  It is available under the GNU GPL.

     FFTW Website, <http://www.fftw.org/>


File: gsl-ref.info,  Node: Numerical Integration,  Next: Random Number Generation,  Prev: Fast Fourier Transforms,  Up: Top

Numerical Integration
*********************

   This chapter describes routines for performing numerical integration
(quadrature) of a function in one dimension.  There are routines for
adaptive and non-adaptive integration of general functions, with
specialised routines for specific cases.  These include integration over
infinite and semi-infinite ranges, singular integrals, including
logarithmic singularities, computation of Cauchy principal values and
oscillatory integrals.  The library reimplements the algorithms used in
QUADPACK, a numerical integration package written by Piessens,
Doncker-Kapenga, Uberhuber and Kahaner.  Fortran code for QUADPACK is
available on Netlib.

   The functions described in this chapter are declared in the header
file `gsl_integration.h'.

* Menu:

* Numerical Integration Introduction::
* QNG non-adaptive Gauss-Kronrod integration::
* QAG adaptive integration::
* QAGS adaptive integration with singularities::
* QAGP adaptive integration with known singular points::
* QAGI adaptive integration on infinite intervals::
* QAWC adaptive integration for Cauchy principal values::
* QAWS adaptive integration for singular functions::
* QAWO adaptive integration for oscillatory functions::
* QAWF adaptive integration for Fourier integrals::
* Numerical integration error codes::
* Numerical integration examples::
* Numerical integration References and Further Reading::


File: gsl-ref.info,  Node: Numerical Integration Introduction,  Next: QNG non-adaptive Gauss-Kronrod integration,  Up: Numerical Integration

Introduction
============

   Each algorithm computes an approximation to a definite integral of
the form,

     I = \int_a^b f(x) w(x) dx

where w(x) is a weight function (for general integrands w(x)=1).  The
user provides absolute and relative error bounds (epsabs, epsrel) which
specify the following accuracy requirement,

     |RESULT - I|  <= max(epsabs, epsrel |I|)

where RESULT is the numerical approximation obtained by the algorithm.
The algorithms attempt to estimate the absolute error ABSERR = |RESULT
- I| in such a way that the following inequality holds,

     |RESULT - I| <= ABSERR <= max(epsabs, epsrel |I|)

The routines will fail to converge if the error bounds are too
stringent, but always return the best approximation obtained up to that
stage.

   The algorithms in QUADPACK use a naming convention based on the
following letters,

     `Q' - quadrature routine
     
     `N' - non-adaptive integrator
     `A' - adaptive integrator
     
     `G' - general integrand (user-defined)
     `W' - weight function with integrand
     
     `S' - singularities can be more readily integrated
     `P' - points of special difficulty can be supplied
     `I' - infinite range of integration
     `O' - oscillatory weight function, cos or sin
     `F' - Fourier integral
     `C' - Cauchy principal value

The algorithms are built on pairs of quadrature rules, a higher order
rule and a lower order rule.  The higher order rule is used to compute
the best approximation to an integral over a small range.  The
difference between the results of the higher order rule and the lower
order rule gives an estimate of the error in the approximation.

   The algorithms for general functions (without a weight function) are
based on Gauss-Kronrod rules. A Gauss-Kronrod rule begins with a
classical Gaussian quadrature rule of order m.  This is extended with
additional points between each of the abscissae to give a higher order
Kronrod rule of order 2m+1.  The Kronrod rule is efficient because it
reuses existing function evaluations from the Gaussian rule.  The
higher order Kronrod rule is used as the best approximation to the
integral, and the difference between the two rules is used as an
estimate of the error in the approximation.

   For integrands with weight functions the algorithms use
Clenshaw-Curtis quadrature rules.  A Clenshaw-Curtis rule begins with
an n-th order Chebyschev polynomial approximation to the integrand.
This polynomial can be integrated exactly to give an approximation to
the integral of the original function.  The Chebyschev expansion can be
extended to higher orders to improve the approximation.  The presence of
singularities (or other behavior) in the integrand can cause slow
convergence in the Chebyschev approximation.  The modified
Clenshaw-Curtis rules used in QUADPACK separate out several common
weight functions which cause slow convergence.  These weight functions
are integrated analytically against the Chebyschev polynomials to
precompute "modified Chebyschev moments".  Combining the moments with
the Chebyschev approximation to the function gives the desired
integral.  The use of analytic integration for the singular part of the
function allows exact cancellations and substantially improves the
overall convergence behavior of the integration.


File: gsl-ref.info,  Node: QNG non-adaptive Gauss-Kronrod integration,  Next: QAG adaptive integration,  Prev: Numerical Integration Introduction,  Up: Numerical Integration

QNG non-adaptive Gauss-Kronrod integration
==========================================

   The QNG algorithm is non-adaptive procedure which uses fixed
Gauss-Kronrod abscissae to sample the integrand at a maximum of 87
points.  It is provided for fast integration of smooth functions.

 - Function: int gsl_integration_qng (const gsl_function *F, double A,
          double B, double EPSABS, double EPSREL, double * RESULT,
          double * ABSERR, size_t * NEVAL)
     This function applies the Gauss-Kronrod 10-point, 21-point,
     43-point and 87-point integration rules in succession until an
     estimate of the integral of f over (a,b) is achieved within the
     desired absolute and relative error limits, EPSABS and EPSREL.  The
     function returns the final approximation, RESULT, an estimate of
     the absolute error, ABSERR and the number of function evaluations
     used, NEVAL.  The Gauss-Kronrod rules are designed in such a way
     that each rule uses all the results of its predecessors, in order
     to minimize the total number of function evaluations.


File: gsl-ref.info,  Node: QAG adaptive integration,  Next: QAGS adaptive integration with singularities,  Prev: QNG non-adaptive Gauss-Kronrod integration,  Up: Numerical Integration

QAG adaptive integration
========================

   The QAG algorithm is a simple adaptive integration procedure.  The
integration region is divided into subintervals, and on each iteration
the subinterval with the largest estimated error is bisected.  This
reduces the overall error rapidly, as the subintervals become
concentrated around local difficulties in the integrand.  These
subintervals are managed by a `gsl_integration_workspace' struct, which
handles the memory for the subinterval ranges, results and error
estimates.

 - Function: gsl_integration_workspace *
          gsl_integration_workspace_alloc (size_t N)
     This function allocates a workspace sufficient to hold N double
     precision intervals, their integration results and error estimates.

 - Function: void gsl_integration_workspace_free
          (gsl_integration_workspace * W)
     This function frees the memory associated with the workspace W.

 - Function: int gsl_integration_qag (const gsl_function *F, double A,
          double B, double EPSABS, double EPSREL, size_t LIMIT, int
          KEY, gsl_integration_workspace * WORKSPACE, double * RESULT,
          double * ABSERR)
     This function applies an integration rule adaptively until an
     estimate of the integral of f over (a,b) is achieved within the
     desired absolute and relative error limits, EPSABS and EPSREL.
     The function returns the final approximation, RESULT, and an
     estimate of the absolute error, ABSERR.  The integration rule is
     determined by the value of KEY, which should be chosen from the
     following symbolic names,

          GSL_INTEG_GAUSS15  (key = 1)
          GSL_INTEG_GAUSS21  (key = 2)
          GSL_INTEG_GAUSS31  (key = 3)
          GSL_INTEG_GAUSS41  (key = 4)
          GSL_INTEG_GAUSS51  (key = 5)
          GSL_INTEG_GAUSS61  (key = 6)

     corresponding to the 15, 21, 31, 41, 51 and 61 point Gauss-Kronrod
     rules.  The higher-order rules give better accuracy for smooth
     functions, while lower-order rules save time when the function
     contains local difficulties, such as discontinuities.

     On each iteration the adaptive integration strategy bisects the
     interval with the largest error estimate.  The subintervals and
     their results are stored in the memory provided by WORKSPACE.  The
     maximum number of subintervals is given by LIMIT, which may not
     exceed the allocated size of the workspace.


File: gsl-ref.info,  Node: QAGS adaptive integration with singularities,  Next: QAGP adaptive integration with known singular points,  Prev: QAG adaptive integration,  Up: Numerical Integration

QAGS adaptive integration with singularities
============================================

   The presence of an integrable singularity in the integration region
causes an adaptive routine to concentrate new subintervals around the
singularity.  As the subintervals decrease in size the successive
approximations to the integral converge in a limiting fashion.  This
approach to the limit can be accelerated using an extrapolation
procedure.  The QAGS algorithm combines adaptive bisection with the Wynn
epsilon-algorithm to speed up the integration of many types of
integrable singularities.

 - Function: int gsl_integration_qags (const gsl_function * F, double
          A, double B, double EPSABS, double EPSREL, size_t LIMIT,
          gsl_integration_workspace * WORKSPACE, double *RESULT, double
          *ABSERR)
     This function applies the Gauss-Kronrod 21-point integration rule
     adaptively until an estimate of the integral of f over (a,b) is
     achieved within the desired absolute and relative error limits,
     EPSABS and EPSREL.  The results are extrapolated using the
     epsilon-algorithm, which accelerates the convergence of the
     integral in the presence of discontinuities and integrable
     singularities.  The function returns the final approximation from
     the extrapolation, RESULT, and an estimate of the absolute error,
     ABSERR.  The subintervals and their results are stored in the
     memory provided by WORKSPACE.  The maximum number of subintervals
     is given by LIMIT, which may not exceed the allocated size of the
     workspace.



File: gsl-ref.info,  Node: QAGP adaptive integration with known singular points,  Next: QAGI adaptive integration on infinite intervals,  Prev: QAGS adaptive integration with singularities,  Up: Numerical Integration

QAGP adaptive integration with known singular points
====================================================

 - Function: int gsl_integration_qagp (const gsl_function * F, double
          *PTS, size_t NPTS, double EPSABS, double EPSREL, size_t
          LIMIT, gsl_integration_workspace * WORKSPACE, double *RESULT,
          double *ABSERR)
     This function applies the adaptive integration algorithm QAGS
     taking account of the user-supplied locations of singular points.
     The array PTS of length NPTS should contain the endpoints of the
     integration ranges defined by the integration region and locations
     of the singularities.  For example, to integrate over the region
     (a,b) with break-points at x_1, x_2, x_3 (where a < x_1 < x_2 <
     x_3 < b) the following PTS array should be used

          pts[0] = a
          pts[1] = x_1
          pts[2] = x_2
          pts[3] = x_3
          pts[4] = b

     with NPTS = 5.

     If you know the locations of the singular points in the integration
     region then this routine will be faster than `QAGS'.



File: gsl-ref.info,  Node: QAGI adaptive integration on infinite intervals,  Next: QAWC adaptive integration for Cauchy principal values,  Prev: QAGP adaptive integration with known singular points,  Up: Numerical Integration

QAGI adaptive integration on infinite intervals
===============================================

 - Function: int gsl_integration_qagi (gsl_function * F, double EPSABS,
          double EPSREL, size_t LIMIT, gsl_integration_workspace *
          WORKSPACE, double *RESULT, double *ABSERR)
     This function computes the integral of the function F over the
     infinite interval (-\infty,+\infty).  The integral is mapped onto
     the interval (0,1] using the transformation x = (1-t)/t,

          \int_{-\infty}^{+\infty} dx f(x) =
               \int_0^1 dt (f((1-t)/t) + f((-1+t)/t))/t^2.

     It is then integrated using the QAGS algorithm.  The normal
     21-point Gauss-Kronrod rule of QAGS is replaced by a 15-point
     rule, because the transformation can generate an integrable
     singularity at the origin.  In this case a lower-order rule is
     more efficient.

 - Function: int gsl_integration_qagiu (gsl_function * F, double A,
          double EPSABS, double EPSREL, size_t LIMIT,
          gsl_integration_workspace * WORKSPACE, double *RESULT, double
          *ABSERR)
     This function computes the integral of the function F over the
     semi-infinite interval (a,+\infty).  The integral is mapped onto
     the interval (0,1] using the transformation x = a + (1-t)/t,

          \int_{a}^{+\infty} dx f(x) =
               \int_0^1 dt f(a + (1-t)/t)/t^2

     and then integrated using the QAGS algorithm.

 - Function: int gsl_integration_qagil (gsl_function * F, double B,
          double EPSABS, double EPSREL, size_t LIMIT,
          gsl_integration_workspace * WORKSPACE, double *RESULT, double
          *ABSERR)
     This function computes the integral of the function F over the
     semi-infinite interval (-\infty,b).  The integral is mapped onto
     the region (0,1] using the transformation x = b - (1-t)/t,

          \int_{+\infty}^{b} dx f(x) =
               \int_0^1 dt f(b - (1-t)/t)/t^2

     and then integrated using the QAGS algorithm.


File: gsl-ref.info,  Node: QAWC adaptive integration for Cauchy principal values,  Next: QAWS adaptive integration for singular functions,  Prev: QAGI adaptive integration on infinite intervals,  Up: Numerical Integration

QAWC adaptive integration for Cauchy principal values
=====================================================

 - Function: int gsl_integration_qawc (gsl_function *F, double A,
          double B, double C, double EPSABS, double EPSREL, size_t
          LIMIT, gsl_integration_workspace * WORKSPACE, double *
          RESULT, double * ABSERR)
     This function computes the Cauchy principal value of the integral
     of f over (a,b), with a singularity at C,

          I = \int_a^b dx f(x) / (x - c)

     The adaptive bisection algorithm of QAG is used, with
     modifications to ensure that subdivisions do not occur at the
     singular point x = c.  When a subinterval contains the point x = c
     or is close to it then a special 25-point modified Clenshaw-Curtis
     rule is used to control the singularity.  Further away from the
     singularity the algorithm uses an ordinary 15-point Gauss-Kronrod
     integration rule.



File: gsl-ref.info,  Node: QAWS adaptive integration for singular functions,  Next: QAWO adaptive integration for oscillatory functions,  Prev: QAWC adaptive integration for Cauchy principal values,  Up: Numerical Integration

QAWS adaptive integration for singular functions
================================================

   The QAWS algorithm is designed for integrands with
algebraic-logarithmic singularities at the end-points of an integration
region.  In order to work efficiently the algorithm requires a
precomputed table of Chebyschev moments.

 - Function: gsl_integration_qaws_table *
gsl_integration_qaws_table_alloc (double ALPHA, double BETA, int MU,
          int NU)
     This function allocates space for a `gsl_integration_qaws_table'
     struct and associated workspace describing a singular weight
     function W(x) with the parameters (\alpha, \beta, \mu, \nu),

          W(x) = (x-a)^alpha (b-x)^beta log^mu (x-a) log^nu (b-x)

     where \alpha < -1, \beta < -1, and \mu = 0, 1, \nu = 0, 1.  The
     weight function can take four different forms depending on the
     values of \mu and \nu,

          W(x) = (x-a)^alpha (b-x)^beta                   (mu = 0, nu = 0)
          W(x) = (x-a)^alpha (b-x)^beta log(x-a)          (mu = 1, nu = 0)
          W(x) = (x-a)^alpha (b-x)^beta log(b-x)          (mu = 0, nu = 1)
          W(x) = (x-a)^alpha (b-x)^beta log(x-a) log(b-x) (mu = 1, nu = 1)

     The singular points (a,b) do not have to be specified until the
     integral is computed, where they are the endpoints of the
     integration range.

     The function returns a pointer to the newly allocated
     `gsl_integration_qaws_table' if no errors were detected, and 0 in
     the case of error.

 - Function: int gsl_integration_qaws_table_set
          (gsl_integration_qaws_table * T, double ALPHA, double BETA,
          int MU, int NU)
     This function modifies the parameters (\alpha, \beta, \mu, \nu) of
     an existing `gsl_integration_qaws_table' struct T.

 - Function: void gsl_integration_qaws_table_free
          (gsl_integration_qaws_table * T)
     This function frees all the memory associated with the
     `gsl_integration_qaws_table' struct T.

 - Function: int gsl_integration_qaws (gsl_function * F, const double
          A, const double B, gsl_integration_qaws_table * T, const
          double EPSABS, const double EPSREL, const size_t LIMIT,
          gsl_integration_workspace * WORKSPACE, double *RESULT, double
          *ABSERR)
     This function computes the integral of the function f(x) over the
     interval (a,b) with the singular weight function (x-a)^\alpha
     (b-x)^\beta \log^\mu (x-a) \log^\nu (b-x).  The parameters of the
     weight function (\alpha, \beta, \mu, \nu) are taken from the table
     T.  The integral is,

          I = \int_a^b dx f(x) (x-a)^alpha (b-x)^beta log^mu (x-a) log^nu (b-x).

     The adaptive bisection algorithm of QAG is used.  When a
     subinterval contains one of the endpoints then a special 25-point
     modified Clenshaw-Curtis rule is used to control the
     singularities.  For subintervals which do not include the
     endpoints an ordinary 15-point Gauss-Kronrod integration rule is
     used.



File: gsl-ref.info,  Node: QAWO adaptive integration for oscillatory functions,  Next: QAWF adaptive integration for Fourier integrals,  Prev: QAWS adaptive integration for singular functions,  Up: Numerical Integration

QAWO adaptive integration for oscillatory functions
===================================================

   The QAWO algorithm is designed for integrands with an oscillatory
factor, \sin(\omega x) or \cos(\omega x).  In order to work efficiently
the algorithm requires a table of Chebyschev moments which must be
pre-computed with calls to the functions below.

 - Function: gsl_integration_qawo_table *
gsl_integration_qawo_table_alloc (double OMEGA, double L, enum
          gsl_integration_qawo_enum SINE, size_t N)
     This function allocates space for a `gsl_integration_qawo_table'
     struct and its associated workspace describing a sine or cosine
     weight function W(x) with the parameters (\omega, L),

          W(x) = sin(omega x)
          W(x) = cos(omega x)

     The parameter L must be the length of the interval over which the
     function will be integrated L = b - a.  The choice of sine or
     cosine is made with the parameter SINE which should be chosen from
     one of the two following symbolic values:

          GSL_INTEG_COSINE
          GSL_INTEG_SINE

     The `gsl_integration_qawo_table' is a table of the trigonometric
     coefficients required in the integration process.  The parameter N
     determines the number of levels of coefficients that are computed.
     Each level corresponds to one bisection of the interval L, so that
     N levels are sufficient for subintervals down to the length L/2^n.
     The integration routine `gsl_integration_qawo' returns the error
     `GSL_ETABLE' if the number of levels is insufficient for the
     requested accuracy.


 - Function: int gsl_integration_qawo_table_set
          (gsl_integration_qawo_table * T, double OMEGA, double L, enum
          gsl_integration_qawo_enum SINE)
     This function changes the parameters OMEGA, L and SINE of the
     existing workspace T.

 - Function: int gsl_integration_qawo_table_set_length
          (gsl_integration_qawo_table * T, double L)
     This function allows the length parameter L of the workspace T to
     be changed.

 - Function: void gsl_integration_qawo_table_free
          (gsl_integration_qawo_table * T)
     This function frees all the memory associated with the workspace T.

 - Function: int gsl_integration_qawo (gsl_function * F, const double
          A, const double EPSABS, const double EPSREL, const size_t
          LIMIT, gsl_integration_workspace * WORKSPACE,
          gsl_integration_qawo_table * WF, double *RESULT, double
          *ABSERR)
     This function uses an adaptive algorithm to compute the integral of
     f over (a,b) with the weight function \sin(\omega x) or
     \cos(\omega x) defined by the table WF.

          I = \int_a^b dx f(x) sin(omega x)
          I = \int_a^b dx f(x) cos(omega x)

     The results are extrapolated using the epsilon-algorithm to
     accelerate the convergence of the integral.  The function returns
     the final approximation from the extrapolation, RESULT, and an
     estimate of the absolute error, ABSERR.  The subintervals and
     their results are stored in the memory provided by WORKSPACE.  The
     maximum number of subintervals is given by LIMIT, which may not
     exceed the allocated size of the workspace.

     Those subintervals with "large" widths d, d\omega > 4 are computed
     using a 25-point Clenshaw-Curtis integration rule, which handles
     the oscillatory behavior.  Subintervals with a "small" width
     d\omega < 4 are computed using a 15-point Gauss-Kronrod
     integration.



File: gsl-ref.info,  Node: QAWF adaptive integration for Fourier integrals,  Next: Numerical integration error codes,  Prev: QAWO adaptive integration for oscillatory functions,  Up: Numerical Integration

QAWF adaptive integration for Fourier integrals
===============================================

 - Function: int gsl_integration_qawf (gsl_function * F, const double
          A, const double EPSABS, const size_t LIMIT,
          gsl_integration_workspace * WORKSPACE,
          gsl_integration_workspace * CYCLE_WORKSPACE,
          gsl_integration_qawo_table * WF, double *RESULT, double
          *ABSERR)
     This function attempts to compute a Fourier integral of the
     function F over the semi-infinite interval [a,+\infty).

          I = \int_a^{+\infty} dx f(x) sin(omega x)
          I = \int_a^{+\infty} dx f(x) cos(omega x)

     The parameter \omega is taken from the table WF (the length L can
     take any value, since it is overridden by this function to a value
     appropriate for the fourier integration).  The integral is computed
     using the QAWO algorithm over each of the subintervals,

          C_1 = [a, a + c]
          C_2 = [a + c, a + 2 c]
          ... = ...
          C_k = [a + (k-1) c, a + k c]

     where c = (2 floor(|\omega|) + 1) \pi/|\omega|.  The width c is
     chosen to cover an odd number of periods so that the contributions
     from the intervals alternate in sign and are monotonically
     decreasing when F is positive and monotonically decreasing.  The
     sum of this sequence of contributions is accelerated using the
     epsilon-algorithm.

     This function works to an overall absolute tolerance of ABSERR.
     The following strategy is used: on each interval C_k the algorithm
     tries to achieve the tolerance

          TOL_k = u_k abserr

     where u_k = (1 - p)p^{k-1} and p = 9/10.  The sum of the geometric
     series of contributions from each interval gives an overall
     tolerance of ABSERR.

     If the integration of a subinterval leads to difficulties then the
     accuracy requirement for subsequent intervals is relaxed,

          TOL_k = u_k max(abserr, max_{i<k}{E_i})

     where E_k is the estimated error on the interval C_k.

     The subintervals and their results are stored in the memory
     provided by WORKSPACE.  The maximum number of subintervals is
     given by LIMIT, which may not exceed the allocated size of the
     workspace.  The integration over each subinterval uses the memory
     provided by CYCLE_WORKSPACE as workspace for the QAWO algorithm.



File: gsl-ref.info,  Node: Numerical integration error codes,  Next: Numerical integration examples,  Prev: QAWF adaptive integration for Fourier integrals,  Up: Numerical Integration

Error codes
===========

   In addition to the standard error codes for invalid arguments the
functions can return the following values,

`GSL_EMAXITER'
     the maximum number of subdivisions was exceeded.

`GSL_EROUND'
     cannot reach tolerance because of roundoff error, or roundoff
     error was detected in the extrapolation table.

`GSL_ESING'
     a non-integrable singularity or other bad integrand behavior was
     found in the integration interval.

`GSL_EDIVERGE'
     the integral is divergent, or too slowly convergent to be
     integrated numerically.


File: gsl-ref.info,  Node: Numerical integration examples,  Next: Numerical integration References and Further Reading,  Prev: Numerical integration error codes,  Up: Numerical Integration

Examples
========

   The integrator `QAGS' will handle a large class of definite
integrals.  For example, consider the following integral, which has a
algebraic-logarithmic singularity at the origin,

     \int_0^1 x^{-1/2} log(x) dx = -4

The program below computes this integral to a relative accuracy bound of
`1e-7'.

     #include <stdio.h>
     #include <math.h>
     #include <gsl/gsl_integration.h>
     
     double f (double x, void * params) {
       double alpha = *(double *) params;
       double f = log(alpha*x) / sqrt(x);
       return f;
     }
     
     int
     main (void)
     {
       gsl_integration_workspace * w
         = gsl_integration_workspace_alloc(1000);
     
       double result, error;
       double expected = -4.0;
       double alpha = 1.0;
     
       gsl_function F;
       F.function = &f;
       F.params = &alpha;
     
       gsl_integration_qags (&F, 0, 1, 0, 1e-7, 1000,
                             w, &result, &error);
     
       printf("result          = % .18f\n", result);
       printf("exact result    = % .18f\n", expected);
       printf("estimated error = % .18f\n", error);
       printf("actual error    = % .18f\n", result - expected);
       printf("intervals =  %d\n", w->size);
     
       return 0;
     }

The results below show that the desired accuracy is achieved after 8
subdivisions.

     bash$ ./a.out
     result          = -3.999999999999973799
     exact result    = -4.000000000000000000
     estimated error =  0.000000000000246025
     actual error    =  0.000000000000026201
     intervals =  8

In fact, the extrapolation procedure used by `QAGS' produces an
accuracy of almost twice as many digits.  The error estimate returned by
the extrapolation procedure is larger than the actual error, giving a
margin of safety of one order of magnitude.


File: gsl-ref.info,  Node: Numerical integration References and Further Reading,  Prev: Numerical integration examples,  Up: Numerical Integration

References and Further Reading
==============================

The following book is the definitive reference for QUADPACK, and was
written by the original authors.  It provides descriptions of the
algorithms, program listings, test programs and examples.  It also
includes useful advice on numerical integration and many references to
the numerical integration literature used in developing QUADPACK.

     R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, D.K. Kahaner.
     `QUADPACK A subroutine package for automatic integration' Springer
     Verlag, 1983.


File: gsl-ref.info,  Node: Random Number Generation,  Next: Quasi-Random Sequences,  Prev: Numerical Integration,  Up: Top

Random Number Generation
************************

The library provides a large collection of random number generators
which can be accessed through a uniform interface.  Environment
variables allow you to select different generators and seeds at runtime,
so that you can easily switch between generators without needing to
recompile your program.  Each instance of a generator keeps track of its
own state, allowing the generators to be used in multi-threaded
programs.  Additional functions are available for transforming uniform
random numbers into samples from continuous or discrete probability
distributions such as the Gaussian, log-normal or Poisson distributions.

   These functions are declared in the header file `gsl_rng.h'.

* Menu:

* General comments on random numbers::
* The Random Number Generator Interface::
* Random number generator initialization::
* Sampling from a random number generator::
* Auxiliary random number generator functions::
* Random number environment variables::
* Saving and restoring random number generator state::
* Random number generator algorithms::
* Unix random number generators::
* Numerical Recipes generators::
* Other random number generators::
* Random Number Generator Performance::
* Random Number Generator Examples::
* Random Number References and Further Reading::
* Random Number Acknowledgements::


File: gsl-ref.info,  Node: General comments on random numbers,  Next: The Random Number Generator Interface,  Up: Random Number Generation

General comments on random numbers
==================================

   In 1988, Park and Miller wrote a paper entitled "Random number
generators: good ones are hard to find." [Commun. ACM, 31, 1192-1201].
Fortunately, some excellent random number generators are available,
though poor ones are still in common use.  You may be happy with the
system-supplied random number generator on your computer, but you should
be aware that as computers get faster, requirements on random number
generators increase.  Nowadays, a simulation that calls a random number
generator millions of times can often finish before you can make it down
the hall to the coffee machine and back.

   A very nice review of random number generators was written by Pierre
L'Ecuyer, as Chapter 4 of the book: Handbook on Simulation, Jerry Banks,
ed. (Wiley, 1997).  The chapter is available in postscript from from
L'Ecuyer's ftp site (see references).  Knuth's volume on Seminumerical
Algorithms (originally published in 1968) devotes 170 pages to random
number generators, and has recently been updated in its 3rd edition
(1997).  It is brilliant, a classic.  If you don't own it, you should
stop reading right now, run to the nearest bookstore, and buy it.

   A good random number generator will satisfy both theoretical and
statistical properties.  Theoretical properties are often hard to obtain
(they require real math!), but one prefers a random number generator
with a long period, low serial correlation, and a tendency _not_ to
"fall mainly on the planes."  Statistical tests are performed with
numerical simulations.  Generally, a random number generator is used to
estimate some quantity for which the theory of probability provides an
exact answer.  Comparison to this exact answer provides a measure of
"randomness".


File: gsl-ref.info,  Node: The Random Number Generator Interface,  Next: Random number generator initialization,  Prev: General comments on random numbers,  Up: Random Number Generation

The Random Number Generator Interface
=====================================

   It is important to remember that a random number generator is not a
"real" function like sine or cosine.  Unlike real functions, successive
calls to a random number generator yield different return values.  Of
course that is just what you want for a random number generator, but to
achieve this effect, the generator must keep track of some kind of
"state" variable.  Sometimes this state is just an integer (sometimes
just the value of the previously generated random number), but often it
is more complicated than that and may involve a whole array of numbers,
possibly with some indices thrown in.  To use the random number
generators, you do not need to know the details of what comprises the
state, and besides that varies from algorithm to algorithm.

   The random number generator library uses two special structs,
`gsl_rng_type' which holds static information about each type of
generator and `gsl_rng' which describes an instance of a generator
created from a given `gsl_rng_type'.

   The functions described in this section are declared in the header
file `gsl_rng.h'.


File: gsl-ref.info,  Node: Random number generator initialization,  Next: Sampling from a random number generator,  Prev: The Random Number Generator Interface,  Up: Random Number Generation

Random number generator initialization
======================================

 - Random: gsl_rng * gsl_rng_alloc (const gsl_rng_type * T)
     This function returns a pointer to a newly-created instance of a
     random number generator of type T.  For example, the following
     code creates an instance of the Tausworthe generator,

          gsl_rng * r = gsl_rng_alloc (gsl_rng_taus);

     If there is insufficient memory to create the generator then the
     function returns a null pointer and the error handler is invoked
     with an error code of `GSL_ENOMEM'.

     The generator is automatically initialized with the default seed,
     `gsl_rng_default_seed'.  This is zero by default but can be changed
     either directly or by using the environment variable `GSL_RNG_SEED'
     (*note Random number environment variables::).

     The details of the available generator types are described later
     in this chapter.

 - Random: void gsl_rng_set (const gsl_rng * R, unsigned long int S)
     This function initializes (or `seeds') the random number
     generator.  If the generator is seeded with the same value of S on
     two different runs, the same stream of random numbers will be
     generated by successive calls to the routines below.  If different
     values of S are supplied, then the generated streams of random
     numbers should be completely different.  If the seed S is zero
     then the standard seed from the original implementation is used
     instead.  For example, the original Fortran source code for the
     `ranlux' generator used a seed of 314159265, and so choosing S
     equal to zero reproduces this when using `gsl_rng_ranlux'.

 - Random: void gsl_rng_free (gsl_rng * R)
     This function frees all the memory associated with the generator R.

